Принципи в ООП
==============================================================================

## 0. Въведение.

- OOП, или обектно-ориентирано програмиране, е програмна парадигма, която използва обекти за представяне и манипулиране на данни. В ООП ние дефинираме класове, които представляват обекти от реалния свят, а обектите са екземпляри на тези класове. OOП ни позволява да организираме кода в модули за многократна употреба, което улеснява писането и поддържането на сложни софтуерни системи.
- Принципите в ООП включват: <br>
    - Абстракция - процесът на скриване на ненужни подробности от потребителя <br>
    - Капсулиране - един обект трябва да предоставя на ползващия го само пряко необходимите му средства за управление <br>
    - Наследяване - позволява да бъдат дефинирани и създавани обекти, които са специализирани варианти на вече съществуващи обекти. Класът наследник взема всички свойства и методи на класа-родител <br>
    - Полиморфизъм - представлява свойството на обектите от един и същи тип да имат един и същи интерфейс, но с различна реализация на този интерфейс <br>

Следва да разгледаме всеки един от тях.


## 1. Абстракция.

- Абстракцията е основен принцип на обектно-ориентираното програмиране (ООП), който ни позволява да представяме сложни системи и концепции от реалния свят по опростен и разбираем начин. Абстракцията е процесът на фокусиране върху основни характеристики и поведение, като същевременно се игнорират ненужните детайли. В Python можем да използваме абстракция, за да създаваме класове и методи, които определят основните свойства и поведение на даден обект, без да се притесняваме за детайлите на изпълнението.
- Един от основните начини, по които можем да използваме абстракция в Python, е чрез дефиниране на абстрактни класове и методи. Абстрактен клас е клас, който не може да бъде инстанциран директно и е предназначен да бъде подклас. Абстрактните класове дефинират абстрактните свойства и поведение на обект, без да предоставят конкретни подробности за изпълнението. Абстрактните методи са методи, които са декларирани, но не са имплементирани в абстрактния клас. Тези методи трябва да бъдат имплементирани от всеки подклас, който наследява от абстрактния клас. <br>
```python
from abc import ABC, abstractmethod # нужни при абстракция

class Vehicle(ABC): # ABC == Abstract Base Class - задаваме базовия клас,
    @abstractmethod # property, чрез което подсказваме на програмата, че следва абстрактен метод
    def start(self):
        pass
    
    @abstractmethod
    def stop(self):
        pass
```
В този пример ние дефинираме абстрактен клас, наречен Vehicle, който представлява абстрактно превозно средство. Класът съдържа два абстрактни метода, start() и stop(), които са предназначени да бъдат имплементирани от всеки подклас, който наследява от Vehicle. Чрез използването на абстрактен клас можем да дефинираме основните свойства и поведение на превозно средство, без да се притесняваме за конкретните детайли на изпълнението за всеки тип превозно средство.


## 2. Капсулиране.

- Капсулирането е принципът на скриване на детайли и данни за внедряване от външния свят и излагане само на необходимото чрез добре дефинирани интерфейси. Използва се за предотвратяване на нежелана модификация на данни и за улесняване на промяната на изпълнението на клас, без да засяга други части на програмата.
- Public атрибути и методи:<br>
Tе са тези, които могат да бъдат достъпни от всяка точка на програмата. Например: <br>
```python
class Person:
    def __init__(self, name):
        self.name = name
        
    def say_hello(self):
        print(f"Hello, my name is {self.name}!")
        
person = Person("John")
print(person.name)  # Output: John
person.say_hello()  # Output: Hello, my name is John!
```

- Private атрибути и методи:<br>
В Python можем да използваме двойно подчертаване (__), за да посочим, че даден атрибут или метод трябва да бъде частен, което означава, че може да бъде достъпен само в рамките на самия клас. Например:<br>
```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age
        
    def get_name(self):
        return self.__name
    
    def get_age(self):
        return self.__age
    
    def __update_age(self, new_age):
        self.__age = new_age
        
person = Person("John", 30)
print(person.get_name())  # Output: John
print(person.get_age())  # Output: 30
person.__name = "Jane"  # Това няма да промени private атрибутa
person.__update_age(31)  # Това няма да работи, тъй като методът е private
print(person.get_age())  # Output: 30
```

- Protected атрибути и методи:<br>
В Python можем да използваме единична долна черта (_), за да посочим, че даден атрибут или метод трябва да бъдат защитени, което означава, че може да бъде достъпен само в рамките на самия клас и неговите подкласове. Например:<br>
```python
class Person:
    def __init__(self, name, age):
        self._name = name  # Protected attribute
        self._age = age  # Protected attribute
        
    def _get_info(self):  # Protected method
        return f"{self._name} is {self._age} years old."
    
class Employee:
    def __init__(self, name, age, salary):
        self._person = Person(name, age)  # Protected attribute
        self.salary = salary  # Public attribute
        
    def get_info(self):
        return self._person._get_info()  # Accessing protected method
    
employee = Employee("John", 30, 5000)
print(employee.salary)  # Output: 5000
print(employee.get_info())  # Output: John is 30 years old.
```


## 3. Наследяване.

- Наследяването е фундаментална концепция в обектно-ориентираното програмиране, която позволява нови класове да бъдат извлечени от съществуващи класове. Наследяването създава връзка родител-дете между класовете, където детето (или подкласът) наследява свойства и поведение от родителя (или суперкласа). В Python можем да дефинираме подклас, като посочим суперкласа в скоби след името на класа. След това подкласът има достъп до методите и атрибутите на суперкласа и може също да дефинира свои собствени методи и атрибути.<br>
```python
class Shape:
    def __init__(self, color):
        self.color = color
        
    def get_color(self):
        return self.color
    
class Rectangle(Shape):
    def __init__(self, color, width, height):
        super().__init__(color)
        self.width = width
        self.height = height
        
    def get_area(self):
        return self.width * self.height
    
rect = Rectangle("red", 5, 10)
print(rect.get_color())  # Output: red
print(rect.get_area())  # Output: 50
```
```super().__init__(color)``` се използва за извикване на конструктора на родителския клас Shape с аргумента color. Това е необходимо, за да се инициализира цветният атрибут на екземпляра Rectangle. Без извикване на ```super().__init__(color)```, цветният атрибут на Rectangle няма да бъде дефиниран.


## 4. Полиморфизъм.

- Полиморфизмът се отнася до способността на обекти от различни типове да се използват взаимозаменяемо в един и същи контекст. В Python полиморфизмът често се постига чрез заместване на метода, което позволява на подклас да предостави различна реализация на метод, който вече е дефиниран в неговия родителски клас.
- Един често срещан пример за полиморфизъм в Python е използването на функцията len(), която може да се използва за получаване на дължината на списък, редица, низ или всеки друг обект, който поддържа метода __len__(). Методът __len__() е вграден метод на Python, който връща дължината на обект.
```python
class Animal:
    def __init__(self, name):
        self.name = name
        
    def speak(self):
        pass
    
class Dog(Animal):
    def speak(self):
        return "Woof!"
        
class Cat(Animal):
    def speak(self):
        return "Meow!"
        
class Bird(Animal):
    def speak(self):
        return "Chirp!"
        
dog = Dog("Buddy")
cat = Cat("Fluffy")
bird = Bird("Tweety")

print(dog.name + " says " + dog.speak())  # Output: Buddy says Woof!
print(cat.name + " says " + cat.speak())  # Output: Fluffy says Meow!
print(bird.name + " says " + bird.speak())  # Output: Tweety says Chirp!
```


## Задачи
1. Създайте клас Calculator, който извършва основни аритметични операции (събиране, изваждане, умножение, деление) с две числа. Въпреки това, вместо да дефинирате отделни методи за всяка операция, имплементирайте един метод, наречен operate, който приема две числа и оператор като аргументи и връща резултата от операцията. Използвайте абстракция, за да постигнете това, като дефинирате operate като абстрактен метод в базов клас калкулатор и след това дефинирате отделни подкласове за всяка операция, които изпълняват operate със съответната операция.
2. Създайте клас Person, с частни атрибути име, възраст и адрес. Капсулирайте тези атрибути, така че да могат да бъдат достъпни и модифицирани само чрез публични методи. Напишете публичен метод get_info(), който отпечатва информацията за човека.
3. Създайте базов клас, наречен Vehicle с атрибути марка, модел и година. След това създайте два подкласа: Car и Motorcycle. Подкласът Car трябва да има допълнителен атрибут, наречен num_doors, докато подкласът Motorcycle трябва да има допълнителен атрибут, наречен num_wheels.
4. Създайте клас, наречен Shape, с метод, наречен area. След това създайте три подкласа: Rectangle, Triangle и Circle. Всеки подклас трябва да има своя собствена реализация на метода area.
